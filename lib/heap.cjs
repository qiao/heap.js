// Generated by CoffeeScript 2.7.0
(function() {

  /*
  Default comparison function to be used
  */
  /*
  Transform list into a heap, in-place, in O(array.length) time.
  */
  /*
  Pop the smallest item off the heap, maintaining the heap invariant.
  */
  /*
  Push item onto heap, maintaining the heap invariant.
  */
  /*
  Fast version of a heappush followed by a heappop.
  */
  /*
  Pop and return the current smallest value, and add the new item.

  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
  */
  /*
  Insert item x in list a, and keep it sorted assuming a is sorted.

  If x is already in a, insert it to the right of the rightmost x.

  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
  */
  /*
  Find the n largest elements in a dataset.
  */
  /*
  Find the n smallest elements in a dataset.
  */
  /*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
  */
  var Heap, _siftdown, _siftup, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem,
    splice = [].splice;

  ({floor, min} = Math);

  defaultCmp = function(x, y) {
    if (x < y) {
      return -1;
    }
    if (x > y) {
      return 1;
    }
    return 0;
  };

  insort = function(a, x, lo = 0, hi, cmp = defaultCmp) {
    var mid;
    if (lo < 0) {
      throw new Error('lo must be non-negative');
    }
    if (hi == null) {
      hi = a.length;
    }
    while (lo < hi) {
      mid = floor((lo + hi) / 2);
      if (cmp(x, a[mid]) < 0) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return (splice.apply(a, [lo, lo - lo].concat(x)), x);
  };

  heappush = function(array, item, cmp = defaultCmp) {
    array.push(item);
    return _siftdown(array, 0, array.length - 1, cmp);
  };

  heappop = function(array, cmp = defaultCmp) {
    var lastelt, returnitem;
    lastelt = array.pop();
    if (array.length) {
      returnitem = array[0];
      array[0] = lastelt;
      _siftup(array, 0, cmp);
    } else {
      returnitem = lastelt;
    }
    return returnitem;
  };

  heapreplace = function(array, item, cmp = defaultCmp) {
    var returnitem;
    returnitem = array[0];
    array[0] = item;
    _siftup(array, 0, cmp);
    return returnitem;
  };

  heappushpop = function(array, item, cmp = defaultCmp) {
    if (array.length && cmp(array[0], item) < 0) {
      [item, array[0]] = [array[0], item];
      _siftup(array, 0, cmp);
    }
    return item;
  };

  heapify = function(array, cmp = defaultCmp) {
    var i, j, len, ref, ref1, results;
    ref1 = (function() {
      var results1 = [];
      for (var k = 0, ref = floor(array.length / 2); 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--){ results1.push(k); }
      return results1;
    }).apply(this).reverse();
    results = [];
    for (j = 0, len = ref1.length; j < len; j++) {
      i = ref1[j];
      results.push(_siftup(array, i, cmp));
    }
    return results;
  };

  updateItem = function(array, item, cmp = defaultCmp) {
    var pos;
    pos = array.indexOf(item);
    if (pos === -1) {
      return;
    }
    _siftdown(array, 0, pos, cmp);
    return _siftup(array, pos, cmp);
  };

  nlargest = function(array, n, cmp = defaultCmp) {
    var elem, j, len, ref, result;
    result = array.slice(0, n);
    if (!result.length) {
      return result;
    }
    heapify(result, cmp);
    ref = array.slice(n);
    for (j = 0, len = ref.length; j < len; j++) {
      elem = ref[j];
      heappushpop(result, elem, cmp);
    }
    return result.sort(cmp).reverse();
  };

  nsmallest = function(array, n, cmp = defaultCmp) {
    var elem, i, j, k, len, los, ref, ref1, result, results;
    if (n * 10 <= array.length) {
      result = array.slice(0, n).sort(cmp);
      if (!result.length) {
        return result;
      }
      los = result[result.length - 1];
      ref = array.slice(n);
      for (j = 0, len = ref.length; j < len; j++) {
        elem = ref[j];
        if (cmp(elem, los) < 0) {
          insort(result, elem, 0, null, cmp);
          result.pop();
          los = result[result.length - 1];
        }
      }
      return result;
    }
    heapify(array, cmp);
    results = [];
    for (i = k = 0, ref1 = min(n, array.length); (0 <= ref1 ? k < ref1 : k > ref1); i = 0 <= ref1 ? ++k : --k) {
      results.push(heappop(array, cmp));
    }
    return results;
  };

  _siftdown = function(array, startpos, pos, cmp = defaultCmp) {
    var newitem, parent, parentpos;
    newitem = array[pos];
    while (pos > startpos) {
      parentpos = (pos - 1) >> 1;
      parent = array[parentpos];
      if (cmp(newitem, parent) < 0) {
        array[pos] = parent;
        pos = parentpos;
        continue;
      }
      break;
    }
    return array[pos] = newitem;
  };

  _siftup = function(array, pos, cmp = defaultCmp) {
    var childpos, endpos, newitem, rightpos, startpos;
    endpos = array.length;
    startpos = pos;
    newitem = array[pos];
    childpos = 2 * pos + 1;
    while (childpos < endpos) {
      rightpos = childpos + 1;
      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
        childpos = rightpos;
      }
      array[pos] = array[childpos];
      pos = childpos;
      childpos = 2 * pos + 1;
    }
    array[pos] = newitem;
    return _siftdown(array, startpos, pos, cmp);
  };

  Heap = (function() {
    class Heap {
      constructor(cmp1 = defaultCmp) {
        this.cmp = cmp1;
        this.nodes = [];
      }

      push(x) {
        return heappush(this.nodes, x, this.cmp);
      }

      pop() {
        return heappop(this.nodes, this.cmp);
      }

      peek() {
        return this.nodes[0];
      }

      contains(x) {
        return this.nodes.indexOf(x) !== -1;
      }

      replace(x) {
        return heapreplace(this.nodes, x, this.cmp);
      }

      pushpop(x) {
        return heappushpop(this.nodes, x, this.cmp);
      }

      heapify() {
        return heapify(this.nodes, this.cmp);
      }

      updateItem(x) {
        return updateItem(this.nodes, x, this.cmp);
      }

      clear() {
        return this.nodes = [];
      }

      empty() {
        return this.nodes.length === 0;
      }

      size() {
        return this.nodes.length;
      }

      clone() {
        var heap;
        heap = new Heap();
        heap.nodes = this.nodes.slice(0);
        return heap;
      }

      toArray() {
        return this.nodes.slice(0);
      }

    };

    Heap.push = heappush;

    Heap.pop = heappop;

    Heap.replace = heapreplace;

    Heap.pushpop = heappushpop;

    Heap.heapify = heapify;

    Heap.updateItem = updateItem;

    Heap.nlargest = nlargest;

    Heap.nsmallest = nsmallest;

    // aliases
    Heap.prototype.insert = Heap.prototype.push;

    Heap.prototype.top = Heap.prototype.peek;

    Heap.prototype.front = Heap.prototype.peek;

    Heap.prototype.has = Heap.prototype.contains;

    Heap.prototype.copy = Heap.prototype.clone;

    return Heap;

  }).call(this);

  // exports to global
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      return define([], factory);
    } else if (typeof exports === 'object') {
      return module.exports = factory();
    } else {
      return root.Heap = factory();
    }
  })(this, function() {
    return Heap;
  });

}).call(this);
