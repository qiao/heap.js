// Generated by CoffeeScript 2.7.0

/*
Default comparison function to be used
*/
/*
Transform list into a heap, in-place, in O(array.length) time.
*/
/*
Pop the smallest item off the heap, maintaining the heap invariant.
*/
/*
Push item onto heap, maintaining the heap invariant.
*/
/*
Fast version of a heappush followed by a heappop.
*/
/*
Pop and return the current smallest value, and add the new item.

This is more efficient than heappop() followed by heappush(), and can be
more appropriate when using a fixed size heap. Note that the value
returned may be larger than item! That constrains reasonable use of
this routine unless written as part of a conditional replacement:
    if item > array[0]
      item = heapreplace(array, item)
*/
    /*
    Insert item x in list a, and keep it sorted assuming a is sorted.

    If x is already in a, insert it to the right of the rightmost x.

    Optional args lo (default 0) and hi (default a.length) bound the slice
    of a to be searched.
    */
    /*
    Find the n largest elements in a dataset.
    */
    /*
    Find the n smallest elements in a dataset.
    */
    /*
    Update the position of the given item in the heap.
    This function should be called every time the item is being modified.
    */
var Heap, _siftdown, _siftup, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem,
  splice = [].splice;

({floor, min} = Math);

defaultCmp = function(x, y) {
  if (x < y) {
    return -1;
  }
  if (x > y) {
    return 1;
  }
  return 0;
};

insort = function(a, x, lo = 0, hi, cmp = defaultCmp) {
  var mid;
  if (lo < 0) {
    throw new Error('lo must be non-negative');
  }
  if (hi == null) {
    hi = a.length;
  }
  while (lo < hi) {
    mid = floor((lo + hi) / 2);
    if (cmp(x, a[mid]) < 0) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  return (splice.apply(a, [lo, lo - lo].concat(x)), x);
};

heappush = function(array, item, cmp = defaultCmp) {
  array.push(item);
  return _siftdown(array, 0, array.length - 1, cmp);
};

heappop = function(array, cmp = defaultCmp) {
  var lastelt, returnitem;
  lastelt = array.pop();
  if (array.length) {
    returnitem = array[0];
    array[0] = lastelt;
    _siftup(array, 0, cmp);
  } else {
    returnitem = lastelt;
  }
  return returnitem;
};

heapreplace = function(array, item, cmp = defaultCmp) {
  var returnitem;
  returnitem = array[0];
  array[0] = item;
  _siftup(array, 0, cmp);
  return returnitem;
};

heappushpop = function(array, item, cmp = defaultCmp) {
  if (array.length && cmp(array[0], item) < 0) {
    [item, array[0]] = [array[0], item];
    _siftup(array, 0, cmp);
  }
  return item;
};

heapify = function(array, cmp = defaultCmp) {
  var i, j, len, ref, ref1, results;
  ref1 = (function() {
    var results1 = [];
    for (var k = 0, ref = floor(array.length / 2); 0 <= ref ? k < ref : k > ref; 0 <= ref ? k++ : k--){ results1.push(k); }
    return results1;
  }).apply(this).reverse();
  results = [];
  for (j = 0, len = ref1.length; j < len; j++) {
    i = ref1[j];
    results.push(_siftup(array, i, cmp));
  }
  return results;
};

updateItem = function(array, item, cmp = defaultCmp) {
  var pos;
  pos = array.indexOf(item);
  if (pos === -1) {
    return;
  }
  _siftdown(array, 0, pos, cmp);
  return _siftup(array, pos, cmp);
};

nlargest = function(array, n, cmp = defaultCmp) {
  var elem, j, len, ref, result;
  result = array.slice(0, n);
  if (!result.length) {
    return result;
  }
  heapify(result, cmp);
  ref = array.slice(n);
  for (j = 0, len = ref.length; j < len; j++) {
    elem = ref[j];
    heappushpop(result, elem, cmp);
  }
  return result.sort(cmp).reverse();
};

nsmallest = function(array, n, cmp = defaultCmp) {
  var elem, i, j, k, len, los, ref, ref1, result, results;
  if (n * 10 <= array.length) {
    result = array.slice(0, n).sort(cmp);
    if (!result.length) {
      return result;
    }
    los = result[result.length - 1];
    ref = array.slice(n);
    for (j = 0, len = ref.length; j < len; j++) {
      elem = ref[j];
      if (cmp(elem, los) < 0) {
        insort(result, elem, 0, null, cmp);
        result.pop();
        los = result[result.length - 1];
      }
    }
    return result;
  }
  heapify(array, cmp);
  results = [];
  for (i = k = 0, ref1 = min(n, array.length); (0 <= ref1 ? k < ref1 : k > ref1); i = 0 <= ref1 ? ++k : --k) {
    results.push(heappop(array, cmp));
  }
  return results;
};

_siftdown = function(array, startpos, pos, cmp = defaultCmp) {
  var newitem, parent, parentpos;
  newitem = array[pos];
  while (pos > startpos) {
    parentpos = (pos - 1) >> 1;
    parent = array[parentpos];
    if (cmp(newitem, parent) < 0) {
      array[pos] = parent;
      pos = parentpos;
      continue;
    }
    break;
  }
  return array[pos] = newitem;
};

_siftup = function(array, pos, cmp = defaultCmp) {
  var childpos, endpos, newitem, rightpos, startpos;
  endpos = array.length;
  startpos = pos;
  newitem = array[pos];
  childpos = 2 * pos + 1;
  while (childpos < endpos) {
    rightpos = childpos + 1;
    if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
      childpos = rightpos;
    }
    array[pos] = array[childpos];
    pos = childpos;
    childpos = 2 * pos + 1;
  }
  array[pos] = newitem;
  return _siftdown(array, startpos, pos, cmp);
};

export default Heap = (function() {
  class Heap {
    constructor(cmp1 = defaultCmp) {
      this.cmp = cmp1;
      this.nodes = [];
    }

    push(x) {
      return heappush(this.nodes, x, this.cmp);
    }

    pop() {
      return heappop(this.nodes, this.cmp);
    }

    peek() {
      return this.nodes[0];
    }

    contains(x) {
      return this.nodes.indexOf(x) !== -1;
    }

    replace(x) {
      return heapreplace(this.nodes, x, this.cmp);
    }

    pushpop(x) {
      return heappushpop(this.nodes, x, this.cmp);
    }

    heapify() {
      return heapify(this.nodes, this.cmp);
    }

    updateItem(x) {
      return updateItem(this.nodes, x, this.cmp);
    }

    clear() {
      return this.nodes = [];
    }

    empty() {
      return this.nodes.length === 0;
    }

    size() {
      return this.nodes.length;
    }

    clone() {
      var heap;
      heap = new Heap();
      heap.nodes = this.nodes.slice(0);
      return heap;
    }

    toArray() {
      return this.nodes.slice(0);
    }

  };

  Heap.push = heappush;

  Heap.pop = heappop;

  Heap.replace = heapreplace;

  Heap.pushpop = heappushpop;

  Heap.heapify = heapify;

  Heap.updateItem = updateItem;

  Heap.nlargest = nlargest;

  Heap.nsmallest = nsmallest;

  // aliases
  Heap.prototype.insert = Heap.prototype.push;

  Heap.prototype.top = Heap.prototype.peek;

  Heap.prototype.front = Heap.prototype.peek;

  Heap.prototype.has = Heap.prototype.contains;

  Heap.prototype.copy = Heap.prototype.clone;

  return Heap;

}).call(this);
